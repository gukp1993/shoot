    1.目标和观察者之间的关系
    目标和观察者一对多（或者一对一）
    一个观察者观察多个目标，需要接收多个目标的通知，如果是一个update方法，在方法内部区分，通知来自哪个目标，
继而做出相应操作。一般，观察者应该为不同的目标定义不同的回调方法。

    2.单向依赖
    观察者依赖于观察目标，观察目标不依赖于观察者。
	
    3.基本的实现说明
    具体的目标实现维护注册的观察者集合
    具体的目标实现需要维护引起通知的状态（即执行了什么操作，就要去通知观察者notifyObservers()）
    具体的观察者实现需要能够接收到目标的通知，能够接收目标传递的数据或者主动去获取目标的数据
    如果一个观察者观察多个目标，那么在观察者的update方法里，需要去判断是来自哪一个目标的通知。
一种是扩展update方法，比如在方法里多传递一个参数进行区分；或者，为每一个目标定义不同的回调

    4.命名建议
    观察者模式又被成为发布--订阅模式
    目标接口的定义，建议在名称后面跟Subject
    观察者接口的定义，建议在名称后面跟Observer
    观察者接口的更新方法，建议名称为update
	
    5.触发通知的时机
    完成了状态维护后触发(执行了操作，再notifyObservers())
	
	6.相互观察
	两套观察者模式：第一套，A,B观察C；第二套，B,C观察A。实际上就是A和C在相互观察，A的状态变化引起C的联动，
C的状态变化也会引起A的联动，注意避免死循环。

	7.观察者模式的调用顺序
	准备阶段：1.创建目标对象，2.创建观察者对象，3.向目标对象注册观察者对象
	实际运行阶段：
		1.改变目标对象的状态，（目标对象具体实现里）
			1.1通知所有注册的观察者对象进行相应的处理，（notifyObservers，通知所有观察者）
				1.1.1回调目标对象，获取相应的数据（notifyObservers里遍历所有注册的观察者，
				观察者回调目标对象，调用update(subject)，观察者获得目标对象信息）
	
	8.通知顺序
	多个观察者之间的功能是平行的，相互不应该有先后的依赖关系。
	
	
	
	
推模型和拉模型

	推模型：目标对象主动向观察者推送目标信息，不管观察者是否需要，广播通信
	拉模型：目标对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，
由观察者主动到目标对象中获取。一般这种模型的实现，会把目标对象自身通过update方法传递
给观察者，观察者通过目标对象的引用来获取。
	
	1.推模型的观察者接口&具体实现
	update方法的入参不在是目标对象的引用，而是具体要推送的信息
	
	2.推模型的目标对象&具体实现
	notifyObsers方法原来没有入参，现在需要入参，具体的推送内容
	循环通知观察者时，即update方法，入参不同
	
	3.客户端使用
	无区别
	
	4.两种模式的比较
	推模型是假定目标对象知道观察者需要的数据；拉模型是目标对象不知道观察者具体需要什么数据，把自身的引用整个
传递给观察者，让观察者按需取值。
	推模型，观察者定义的update方法是按需取值，这意味着出现新情况，可能需要修改，使得观察者难以复用。
	
	
Java中的观察者模式
	java提供了观察者模式的实现，java.util包下的Observable类和Observer接口
	目标对象继承Observable类，目标对象维护状态，执行this.setChanged方法，this.notifyObservers方法，带参数是推模式，不带参数是拉模式
	观察者实现Observer接口，复写update(Observable o,Object obj)方法，两种模式，观察者都能获得目标对象的引用o，推模式下，obj不为null，
可以获得具体推送的内容。
	客户端没变化
	
	
观察者模式的优缺点
	观察者模式的优点
	1.观察者模式实现了观察者和目标之间的抽象耦合
	原本目标对象在状态发生改变的时候，需要直接调用所有的观察者对象，但是抽象出观察者接口以后，目标对象就只是在抽象层面
上耦合了，也就是说目标只是知道观察者接口，并不知道具体的观察者类，从而实现目标类和具体的观察者类之间的解耦。
	2.观察者模式实现了动态联动
	所谓联动，就是做一个操作会引起其他相关的操作。由于观察者模式对观察者注册实行管理，那就可以在运行期间，通过动态地控制
注册的观察者，来控制某个动作的联动范围，从而实现动态联动。
	3.观察者模式支持广播通信
	由于目标发送通知给观察者是面向所有注册的观察者，所以每次目标通知的信息就要对所有注册的观察者进行广播。当然也可以通过
在目标上添加新的功能来限制广播的范围。

	观察者模式的缺点
	1.可能引起无谓的操作
	由于观察者模式每次都是广播通信，不管观察者需不需要，每个观察者都会去调用update方法，如果观察者不需要执行相应处理，那么
这次操作就浪费了，或者引起误更新



	观察者模式的本质，触发联动
	何时选用观察者模式？
	1.当一个抽象模型有两个方面，其中一个方面的操作依赖于另一个方面的状态变化，那么就可以选用观察者模式，将这两者封装成
观察者和目标对象，当目标对象变化时，依赖于它的观察者也会发生相应的变化。这样就把抽象模型的这两个方面分离开了，使得它们
可以独立地改变和复用。
	2.如果在更改一个对象的时候，需要同时连带改变其他的对象，而且不知道究竟应该有多少对象需要被连带改变，这种情况可以选用
观察者模式，被更改的那一个对象很明显就是目标对象，而需要连带修改的多个其他对象，就作为多个观察者对象了。
	3.当一个对象必须通知其他的对象，但是你又希望这个对象和其他被它通知的对象是松散耦合的。也就是说这个对象其实不想知道
具体被通知的对象。这种情况可以选用观察者模式，这个对象就相当于是目标对象，而被它通知的对象就是观察者对象。
	
	
	
	
	
	
	
	

	
	